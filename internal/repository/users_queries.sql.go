// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users_queries.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users
(id, email, hash_password)
VALUES
($1, $2, $3)
RETURNING id, created_at
`

type CreateUserParams struct {
	ID           uuid.UUID `db:"id"`
	Email        string    `db:"email"`
	HashPassword string    `db:"hash_password"`
}

type CreateUserRow struct {
	ID        uuid.UUID          `db:"id"`
	CreatedAt pgtype.Timestamptz `db:"created_at"`
}

func (q *Queries) CreateUser(ctx context.Context, arg *CreateUserParams) (*CreateUserRow, error) {
	row := q.db.QueryRow(ctx, createUser, arg.ID, arg.Email, arg.HashPassword)
	var i CreateUserRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return &i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT
    id,
    email,
    created_at,
    updated_at
FROM users
WHERE id = $1 AND deleted_at IS NULL
LIMIT 1
`

type GetUserByIDParams struct {
	ID uuid.UUID `db:"id"`
}

type GetUserByIDRow struct {
	ID        uuid.UUID          `db:"id"`
	Email     string             `db:"email"`
	CreatedAt pgtype.Timestamptz `db:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at"`
}

func (q *Queries) GetUserByID(ctx context.Context, arg *GetUserByIDParams) (*GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, arg.ID)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getUserHashPassword = `-- name: GetUserHashPassword :one
SELECT
    id,
    hash_password
FROM users
WHERE email = $1 AND deleted_at IS NULL
LIMIT 1
`

type GetUserHashPasswordParams struct {
	Email string `db:"email"`
}

type GetUserHashPasswordRow struct {
	ID           uuid.UUID `db:"id"`
	HashPassword string    `db:"hash_password"`
}

func (q *Queries) GetUserHashPassword(ctx context.Context, arg *GetUserHashPasswordParams) (*GetUserHashPasswordRow, error) {
	row := q.db.QueryRow(ctx, getUserHashPassword, arg.Email)
	var i GetUserHashPasswordRow
	err := row.Scan(&i.ID, &i.HashPassword)
	return &i, err
}

const hardDeleteUser = `-- name: HardDeleteUser :one
DELETE FROM users
WHERE id = $1
RETURNING id
`

type HardDeleteUserParams struct {
	ID uuid.UUID `db:"id"`
}

func (q *Queries) HardDeleteUser(ctx context.Context, arg *HardDeleteUserParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, hardDeleteUser, arg.ID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const listUser = `-- name: ListUser :many
SELECT
    id,
    email,
    created_at,
    updated_at
FROM users
LIMIT $1 OFFSET $2
`

type ListUserParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

type ListUserRow struct {
	ID        uuid.UUID          `db:"id"`
	Email     string             `db:"email"`
	CreatedAt pgtype.Timestamptz `db:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at"`
}

func (q *Queries) ListUser(ctx context.Context, arg *ListUserParams) ([]*ListUserRow, error) {
	rows, err := q.db.Query(ctx, listUser, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUserRow
	for rows.Next() {
		var i ListUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteUser = `-- name: SoftDeleteUser :one
UPDATE users
SET
    deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, deleted_at
`

type SoftDeleteUserParams struct {
	ID uuid.UUID `db:"id"`
}

type SoftDeleteUserRow struct {
	ID        uuid.UUID          `db:"id"`
	DeletedAt pgtype.Timestamptz `db:"deleted_at"`
}

func (q *Queries) SoftDeleteUser(ctx context.Context, arg *SoftDeleteUserParams) (*SoftDeleteUserRow, error) {
	row := q.db.QueryRow(ctx, softDeleteUser, arg.ID)
	var i SoftDeleteUserRow
	err := row.Scan(&i.ID, &i.DeletedAt)
	return &i, err
}

const updateUserEmail = `-- name: UpdateUserEmail :one
UPDATE users
SET
    email = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, updated_at
`

type UpdateUserEmailParams struct {
	ID    uuid.UUID `db:"id"`
	Email string    `db:"email"`
}

type UpdateUserEmailRow struct {
	ID        uuid.UUID          `db:"id"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at"`
}

func (q *Queries) UpdateUserEmail(ctx context.Context, arg *UpdateUserEmailParams) (*UpdateUserEmailRow, error) {
	row := q.db.QueryRow(ctx, updateUserEmail, arg.ID, arg.Email)
	var i UpdateUserEmailRow
	err := row.Scan(&i.ID, &i.UpdatedAt)
	return &i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :one
UPDATE users
SET
    hash_password = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, updated_at
`

type UpdateUserPasswordParams struct {
	ID           uuid.UUID `db:"id"`
	HashPassword string    `db:"hash_password"`
}

type UpdateUserPasswordRow struct {
	ID        uuid.UUID          `db:"id"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg *UpdateUserPasswordParams) (*UpdateUserPasswordRow, error) {
	row := q.db.QueryRow(ctx, updateUserPassword, arg.ID, arg.HashPassword)
	var i UpdateUserPasswordRow
	err := row.Scan(&i.ID, &i.UpdatedAt)
	return &i, err
}
